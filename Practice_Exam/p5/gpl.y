// Mon Apr 27 16:03:16 PDT 2020
// bison syntax indicating C++ declarations required by both the parser and scanner
%code requires {
    #include <cassert>
    //#include "Scope_manager.h"
    #include "Constant.h"
    using namespace GPL;
  #include <string>
  #include "Rectangle.h"
    #include "Circle.h"
    #include "Textbox.h"
    #include "Pixmap.h"
    #include "Triangle.h"
  class Expression;
  class Variable;
  struct Parameter;
  class Statement;
  #ifndef P1
    #include "types_and_ops.h"  //include in all projects except the first
  #endif
  #ifdef GRAPHICS
    #include "Window.h"
  #endif
  #include "Variable.h"
  #include "Statement.h"
  #include "Event_manager.h"
}

// bison syntax to indicate the beginning of a C/C++ code section
%{

extern int yylex();  // prototype of function generated by flex
extern int yyerror(const char *); // used to print errors
extern int line_count;            // current line in the input; from record.l

#include "error.h"      // class for printing errors (used by gpl)
#include <iostream>

// bison syntax indicating the end of a C/C++ code section
%} 


// turn on verbose (longer) error messages
%define parse.error verbose

%union {
 int                union_int;
 std::string*       union_string;  // MUST be a pointer to a string
 double             union_double;
 GPL::Type          union_gpl_type;
 const Expression*  union_expression_ptr;
 const Variable*    union_variable_ptr;
 Parameter*         union_parameter_ptr;
 Statement*         union_statement_ptr;
 Window::Keystroke union_keystroke_ptr;
};
%{
	template<typename OP, GPL::Operator optype>
	const Expression* Bin_op_check(const Expression* one, const Expression* three, unsigned int valid_types)
	{ 
	bool lhs_valid=one->type() & valid_types;
	bool rhs_valid=three->type() & valid_types;
	if(lhs_valid && rhs_valid)
		return new OP(one, three); 
	if(!lhs_valid) { Error::error(Error::INVALID_LEFT_OPERAND_TYPE,  to_string(optype)); }
	if(!rhs_valid) { Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, to_string(optype)); }
	delete one;
	delete three;
	return new Integer_constant(0);
	}
	template<typename OP, GPL::Operator optype>
	const Expression* Un_op_check(const Expression* one, unsigned int valid_types)
	{
		bool rhs_valid=one->type() & valid_types;
		if(rhs_valid)
		{
			return new OP(one);
		}
		if(!rhs_valid)
		{
			Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, to_string(optype));
		}
		delete one;
		return new Integer_constant(0);
	}
    struct Parameter {
      const Expression* value;
      std::string name;
      Parameter* next=nullptr; //default initialization
      ~Parameter() { delete next; }
    };
%}
%destructor { delete $$; } <union_string>
// tokens declared here
// tokens declared here
 /* updated January 2019 
  * Copy the following token declarations into your .y file. */

 /* Tokens with angle braces < > after %token require a type. 
  * This is the type of the variable the scanner (flex) puts into the union.
  * Fill in the < > with the appropriate union variable
  *     for example
  *     %token <union_int> T_INT_CONSTANT       "int constant" 
  */

%token T_INT                 "int"
%token T_DOUBLE              "double"
%token T_STRING              "string"
%token T_TRIANGLE            "triangle"
%token T_PIXMAP              "pixmap"
%token T_CIRCLE              "circle"
%token T_RECTANGLE           "rectangle"
%token T_TEXTBOX             "textbox"

%token T_FORWARD             "forward"
%token T_INITIALIZATION      "initialization"
%token T_TERMINATION         "termination"
%token T_ON                  "on"
%token T_ANIMATION           "animation"
%token T_IF                  "if"
%token T_FOR                 "for"
%token T_ELSE                "else"
%token <union_int> T_EXIT            "exit"  /* value is line number */
%token <union_int> T_PRINT           "print"  /* value is line number */
%token T_TRUE                "true"
%token T_FALSE               "false"

%token T_SPACE               "space"
%token T_LEFTARROW           "leftarrow"
%token T_RIGHTARROW          "rightarrow"
%token T_UPARROW             "uparrow"
%token T_DOWNARROW           "downarrow"
%token T_LEFTMOUSE_DOWN      "leftmouse_down"
%token T_MIDDLEMOUSE_DOWN    "middlemouse_down"
%token T_RIGHTMOUSE_DOWN     "rightmouse_down"
%token T_LEFTMOUSE_UP        "leftmouse_up"
%token T_MIDDLEMOUSE_UP      "middlemouse_up"
%token T_RIGHTMOUSE_UP       "rightmouse_up"
%token T_MOUSE_MOVE          "mouse_move"
%token T_MOUSE_DRAG          "mouse_drag"
%token T_F1                  "f1"
%token T_AKEY                "akey"
%token T_SKEY                "skey"
%token T_DKEY                "dkey"
%token T_FKEY                "fkey"
%token T_HKEY                "hkey"
%token T_JKEY                "jkey"
%token T_KKEY                "kkey"
%token T_LKEY                "lkey"
%token T_WKEY                "wkey"
%token T_ZKEY                "zkey"

%token T_LPAREN              "("
%token T_RPAREN              ")"
%token T_LBRACE              "{"
%token T_RBRACE              "}"
%token T_LBRACKET            "["
%token T_RBRACKET            "]"
%token T_SEMIC               ";"
%token T_COMMA               ","
%token T_PERIOD              "."

%token T_ASSIGN              "="
%token T_PLUS_ASSIGN         "+="
%token T_MINUS_ASSIGN        "-="
%token T_PLUS_PLUS           "++"
%token T_MINUS_MINUS         "--"

%token T_SIN                 "sin"
%token T_COS                 "cos"
%token T_TAN                 "tan"
%token T_ASIN                "asin"
%token T_ACOS                "acos"
%token T_ATAN                "atan"
%token T_SQRT                "sqrt"
%token T_ABS                 "abs"
%token T_FLOOR               "floor"
%token T_RANDOM              "random"

%token T_TOUCHES             "touches"
%token T_NEAR                "near"

%token T_MULTIPLY            "*"
%token T_DIVIDE              "/"
%token T_PLUS                "+"
%token T_MINUS               "-"
%token T_MOD                 "%"

%token T_LESS                "<"
%token T_GREATER             ">"
%token T_LESS_EQUAL          "<="
%token T_GREATER_EQUAL       ">="
%token T_EQUAL               "=="
%token T_NOT_EQUAL           "!="
%token T_NOT                 "!"
%token T_AND                 "&&"
%token T_OR                  "||"
%token T_REPEAT              "repeat"
%token T_UNTIL               "until"

%token <union_int>    T_INT_CONSTANT    "int constant"
%token <union_double> T_DOUBLE_CONSTANT "double constant"
%token <union_string> T_STRING_CONSTANT "string constant"
%token <union_string> T_ID            	 "identifier"

 /* special token that does not match any production */
 /* used for characters that are not part of the language */
%token T_ERROR               "error"
%type <union_gpl_type> simple_type
%type <union_gpl_type> object_type
%type <union_expression_ptr> primary_expression
%type <union_expression_ptr> expression
%type <union_expression_ptr> optional_initializer
%type <union_variable_ptr> variable
%type <union_parameter_ptr> parameter
%type <union_parameter_ptr> parameter_list
%type <union_parameter_ptr> parameter_list_or_empty
%type <union_statement_ptr> print_statement
%type <union_statement_ptr> statement
%type <union_statement_ptr> statement_block
%type <union_statement_ptr> statement_list
%type <union_keystroke_ptr> keystroke
%type <union_statement_ptr> assign_statement
%type <union_statement_ptr> if_statement
%type <union_statement_ptr> for_statement
%type <union_statement_ptr> exit_statement
%type <union_statement_ptr> statement_or_block_of_statements
%type <union_statement_ptr> assign_statement_or_empty
%type <union_statement_ptr> repeat_until
//precedence
%left T_OR
%left T_AND
%left T_NOT_EQUAL T_EQUAL
%left T_GREATER_EQUAL T_LESS_EQUAL T_GREATER T_LESS
%left T_PLUS T_MINUS
%left T_MULTIPLY T_DIVIDE T_MOD
%nonassoc T_NOT UNARY_OPS
%nonassoc T_NEAR T_TOUCHES
%nonassoc IF_NO_ELSE
%nonassoc T_ELSE

%%
// updated October 2021

//---------------------------------------------------------------------
program:
    declaration_list block_list


//---------------------------------------------------------------------
declaration_list:
    declaration_list declaration
    | %empty


//---------------------------------------------------------------------
declaration:
    variable_declaration T_SEMIC
    | object_declaration T_SEMIC
    | forward_declaration T_SEMIC


//---------------------------------------------------------------------
variable_declaration:
    simple_type  T_ID  optional_initializer
    {
		Scope_manager& sm=Scope_manager::instance();
		if(sm.defined_in_current_scope(*$2))
		{
			Error::error(Error::PREVIOUSLY_DECLARED_VARIABLE,*$2);
			delete $2;
			break;
		}
        try
		{
			switch($1)
			{
				case GPL::INT:
				{
					int* ptr;
					if($3==nullptr)
					{
						ptr=new int(0);
					}
					else
					{
						ptr=new int($3->evaluate()->as_int());
					}
					sm.add_to_current_scope(std::make_shared<Symbol>(*$2,ptr));
					break;
				}
				case GPL::DOUBLE:
				{
					double* ptr;
					if($3==nullptr)
					{
						ptr=new double(0.0);
					}
					else
					{
						ptr=new double($3->evaluate()->as_double());
					}
					sm.add_to_current_scope(std::make_shared<Symbol>(*$2,ptr));
					break;
				}
				case GPL::STRING:
				{
					std::string* ptr;
					if($3==nullptr)
					{
						ptr=new std::string("");
					}
					else
					{
						ptr=new std::string($3->evaluate()->as_string());
					}
					sm.add_to_current_scope(std::make_shared<Symbol>(*$2,ptr));
					break;
				}
				default:
					assert(false);
				
			}
		}
        catch(GPL::Type actual_type)
		{
			Error::error(Error::INVALID_TYPE_FOR_INITIAL_VALUE, GPL::to_string(actual_type), *$2, GPL::to_string($1));
			switch($1)
			{
				case GPL::INT:
					sm.add_to_current_scope(std::make_shared<Symbol>(*$2, new int(0)));
					break;
				case GPL::DOUBLE:
					sm.add_to_current_scope(std::make_shared<Symbol>(*$2, new double(0.0)));
					break;
				case GPL::STRING:
					sm.add_to_current_scope(std::make_shared<Symbol>(*$2, new std::string("")));
					break;
				default:
					assert(false);
			}
		}
        delete $2; 
        delete $3;
	}
    | simple_type  T_ID T_LBRACKET expression T_RBRACKET
    {

		Scope_manager& sm=Scope_manager::instance();
		if($4->type()!=GPL::INT)
		{
			Error::error(Error::ARRAY_SIZE_MUST_BE_AN_INTEGER,GPL::to_string($4->type()),*$2);
            int size = 1; 
            int *data = new int[1]; 
            for(int i = 0; i < size; i++)
            {
                data[i] = 0; 
            }
            sm.add_to_current_scope(std::make_shared<Symbol> (*$2, data, size));
			delete $2;
            delete $4;
			break;
		}


        int temp = $4->evaluate()->as_int();
        if(temp < 1)
        {
            Error::error(Error::INVALID_ARRAY_SIZE,*$2, std::to_string(temp));
            int size = 1; 
            int *data = new int[1]; 
            for(int i = 0; i < size; i++)
            {
                data[i] = 0; 
            }

            if (sm.defined_in_current_scope(*$2)) 
            {
                Error::error(Error::PREVIOUSLY_DECLARED_VARIABLE,*$2);
                delete data;
                delete $2;
                delete $4;
                break; 
            }
            else
                sm.add_to_current_scope(std::make_shared<Symbol> (*$2, data, size));  
            //delete data;
            delete $2; 
            delete $4;
            break;
        }

		if(sm.defined_in_current_scope(*$2))
		{
			Error::error(Error::PREVIOUSLY_DECLARED_VARIABLE,*$2);
			delete $2;
            delete $4;
			break;
		}
		try
		{
			switch($1)
			{
				case GPL::INT:
				{
					int* ptr=new int[($4->evaluate()->as_int())];
					for(int i=0; i<$4->evaluate()->as_int(); i++)
					{
						ptr[i]=0;
					}
					sm.add_to_current_scope(std::make_shared<Symbol>(*$2, ptr, $4->evaluate()->as_int()));
					break;
				}
				case GPL::DOUBLE:
				{
					double* ptr=new double[($4->evaluate()->as_int())];
					for(int i=0; i<$4->evaluate()->as_int(); i++)
					{
						ptr[i]=0;
					}
					sm.add_to_current_scope(std::make_shared<Symbol>(*$2, ptr, $4->evaluate()->as_int()));
					
					break;
				}
				case GPL::STRING:
				{
					std::string* ptr=new std::string[($4->evaluate()->as_int())];
					for(int i=0; i<$4->evaluate()->as_int(); i++)
					{
						ptr[i]="";
					}
					sm.add_to_current_scope(std::make_shared<Symbol>(*$2, ptr, $4->evaluate()->as_int()));
					
					break;
				}
				default:
					assert(false);

			}
		}catch(GPL::Type actual_type)
		{
            Error::error(Error::INVALID_TYPE_FOR_INITIAL_VALUE, GPL::to_string(actual_type), *$2, GPL::to_string($1));
            switch(actual_type)
			{
				case GPL::INT:
                {
                    int size=1;
                    int* ptr= new int[1];
                    for(int i =0; i<size; i++)
                    {
                        ptr[i]=0;
                    }
					sm.add_to_current_scope(std::make_shared<Symbol>(*$2, ptr, size));
					break;
                }
				case GPL::DOUBLE:
                {
					int size=1;
                    int* ptr= new int[1];
                    for(int i =0; i<size; i++)
                    {
                        ptr[i]=0;
                    }
					sm.add_to_current_scope(std::make_shared<Symbol>(*$2, ptr, size));
					break;
                }
				case GPL::STRING:
                {
					int size=1;
                    int* ptr= new int[1];
                    for(int i =0; i<size; i++)
                    {
                        ptr[i]=0;
                    }
					sm.add_to_current_scope(std::make_shared<Symbol>(*$2, ptr, size));
					break;
                }
				default:
					assert(false);
			}
		}
		delete $2;
        delete $4;
	}


//---------------------------------------------------------------------
simple_type:
    T_INT      {$$=GPL::INT;}
    | T_DOUBLE {$$=GPL::DOUBLE;}
    | T_STRING {$$=GPL::STRING;}


//---------------------------------------------------------------------
optional_initializer:
    T_ASSIGN expression { $$=$2; }
    | %empty {$$=nullptr;}


//---------------------------------------------------------------------
object_declaration:
    object_type T_ID parameter_list_or_empty {
        Scope_manager& sm=Scope_manager::instance();
        Game_object* gop;
        if(sm.defined_in_current_scope(*$2)){
            Error::error(Error::PREVIOUSLY_DECLARED_VARIABLE, *$2);
            delete $2;
            break; 
        }
        switch($1)
        {
            case GPL::RECTANGLE:
            {
                Rectangle* ptr=new Rectangle();
                gop=ptr;
                sm.add_to_current_scope(std::make_shared<Symbol>(*$2, ptr));
                break;
            }
            case GPL::CIRCLE:
            {
                Circle* ptr=new Circle();
                gop=ptr;
                sm.add_to_current_scope(std::make_shared<Symbol>(*$2, ptr));
                break;
            }
            case GPL::TRIANGLE:
            {
                Triangle* ptr=new Triangle();
                gop=ptr;
                sm.add_to_current_scope(std::make_shared<Symbol>(*$2, ptr));
                break;
            }
            case GPL::PIXMAP:
            {
                Pixmap* ptr=new Pixmap();
                gop=ptr;
                sm.add_to_current_scope(std::make_shared<Symbol>(*$2, ptr));
                break;
            }
            case GPL::TEXTBOX:
            {
                Textbox* ptr=new Textbox();
                gop=ptr;
                sm.add_to_current_scope(std::make_shared<Symbol>(*$2, ptr));
                break;
            }
            default:
                assert(false);
        }
        Parameter* par=$3;
        while(par)
        {
            try
            {
                switch(gop->attribute_type(par->name))
                {
                    case GPL::INT:
                    {
                        gop->write_attribute(par->name, par->value->evaluate()->as_int());
                        break;
                    }
                    case GPL::DOUBLE:
                    {
                        gop->write_attribute(par->name, par->value->evaluate()->as_double());
                        break;
                    }
                    case GPL::STRING:
                    {
                        gop->write_attribute(par->name, par->value->evaluate()->as_string());
                        break;
                    }
                    default:
                        assert(false);
                    
                }
            par=par->next;
            }catch(const out_of_range& ex)
            {
                Error::error(Error::UNKNOWN_CONSTRUCTOR_PARAMETER, *$2, par->name);
                par=par->next;
            }
            catch(GPL::Type actual_type)
            {
                Error::error(Error::INCORRECT_CONSTRUCTOR_PARAMETER_TYPE, *$2, par->name);
                par = par->next;
            }
        }
        delete $2;
        delete $3;
    }
    | object_type T_ID T_LBRACKET expression T_RBRACKET {
        Scope_manager& sm=Scope_manager::instance();
        int i=-1;
        try{
            i=$4->evaluate()->as_int();
        }catch(GPL::Type actual_type){
            Error::error(Error::ARRAY_SIZE_MUST_BE_AN_INTEGER, GPL::to_string(actual_type), *$2);
            i=1;
        }
        if(i<1)
        {
            Error::error(Error::INVALID_ARRAY_SIZE, *$2, std::to_string(i));
            i=1;
        }
        if(sm.defined_in_current_scope(*$2))
        {
            Error::error(Error::PREVIOUSLY_DECLARED_VARIABLE, *$2);
            delete $2;
            delete $4;
            break;
        }
        switch($1)
        {
            case TRIANGLE:
            {
                Triangle* triangle_arr = new Triangle[i];
                sm.add_to_current_scope(std::make_shared<Symbol>(*$2, triangle_arr, i));
                break;
            }
            case CIRCLE:
            {
                Circle* circle_arr = new Circle[i];
                sm.add_to_current_scope(std::make_shared<Symbol>(*$2, circle_arr, i));
                break;
            }
            case RECTANGLE:
            {
                Rectangle* ptr=new Rectangle[i];
                sm.add_to_current_scope(std::make_shared<Symbol>(*$2, ptr, i));
                break;
            }
            case PIXMAP:
            {
                Pixmap* pixmap_arr = new Pixmap[i];
                sm.add_to_current_scope(std::make_shared<Symbol>(*$2, pixmap_arr, i));
                break;
            }
            case TEXTBOX:
            {
                Textbox* textbox_arr = new Textbox[i];
                sm.add_to_current_scope(std::make_shared<Symbol>(*$2, textbox_arr, i));
                break;
            }
            default:
                assert(false);
        }
        
    };


//---------------------------------------------------------------------
object_type:
    T_TRIANGLE   {$$ = GPL::TRIANGLE;}
    | T_PIXMAP   {$$ = GPL::PIXMAP;}
    | T_CIRCLE   {$$ = GPL::CIRCLE;}
    | T_RECTANGLE{$$ = GPL::RECTANGLE;}
    | T_TEXTBOX  {$$ = GPL::TEXTBOX;}


//---------------------------------------------------------------------
parameter_list_or_empty :
    T_LPAREN parameter_list T_RPAREN{$$=$2;}
    | T_LPAREN T_RPAREN{$$=nullptr;}
    | %empty {$$=nullptr;}


//---------------------------------------------------------------------
parameter_list :
    parameter_list T_COMMA parameter
    {
        Parameter* prev=$1;
        while(prev->next!=nullptr)
        {
            prev=prev->next;
        }
        prev->next=$3;
        $$=$1;
    }
    | parameter{$$=$1;}


//---------------------------------------------------------------------
parameter:
    T_ID T_ASSIGN expression{
        $$=new Parameter{$3, *$1, nullptr};
        delete $1;
    };

//---------------------------------------------------------------------
block_list:
    block_list block
    | %empty


//---------------------------------------------------------------------
block:
    initialization_block
    | termination_block
    | animation_block
    | on_block


//---------------------------------------------------------------------
initialization_block:
    T_INITIALIZATION statement_block


//---------------------------------------------------------------------
termination_block:
    T_TERMINATION statement_block


//---------------------------------------------------------------------
forward_declaration:
    T_FORWARD T_ANIMATION T_ID T_LPAREN animation_parameter T_RPAREN  {$3; /*CHANGE*/}


//---------------------------------------------------------------------
animation_parameter:
    object_type T_ID {$2; /*CHANGE*/}
    | object_type


//---------------------------------------------------------------------
animation_block:
    animation_declaration statement_block


//---------------------------------------------------------------------
animation_declaration:
    T_ANIMATION T_ID T_LPAREN object_type T_ID T_RPAREN {$5,$2; /*CHANGE*/}


//---------------------------------------------------------------------
on_block:
    T_ON keystroke statement_block
    {
        Event_manager& keyvent = Event_manager::instance();
        keyvent.add_handler($2,$3);
    }


//---------------------------------------------------------------------
keystroke:
    T_SPACE              {$$=Window::SPACE;}
    | T_UPARROW          {$$=Window::UPARROW;}              
    | T_DOWNARROW        {$$=Window::DOWNARROW;}                
    | T_LEFTARROW        {$$=Window::LEFTARROW;}                
    | T_RIGHTARROW       {$$=Window::RIGHTARROW;}                 
    | T_LEFTMOUSE_DOWN   {$$=Window::LEFTMOUSE_DOWN;}                     
    | T_MIDDLEMOUSE_DOWN {$$=Window::MIDDLEMOUSE_DOWN;}                       
    | T_RIGHTMOUSE_DOWN  {$$=Window::RIGHTMOUSE_DOWN;}                      
    | T_LEFTMOUSE_UP     {$$=Window::LEFTMOUSE_UP;}                   
    | T_MIDDLEMOUSE_UP   {$$=Window::MIDDLEMOUSE_UP;}                     
    | T_RIGHTMOUSE_UP    {$$=Window::RIGHTMOUSE_UP;}                    
    | T_MOUSE_MOVE       {$$=Window::MOUSE_MOVE;}                 
    | T_MOUSE_DRAG       {$$=Window::MOUSE_DRAG;}                 
    | T_AKEY             {$$=Window::AKEY;}           
    | T_SKEY             {$$=Window::SKEY;}           
    | T_DKEY             {$$=Window::DKEY;}           
    | T_FKEY             {$$=Window::FKEY;}           
    | T_HKEY             {$$=Window::HKEY;}           
    | T_JKEY             {$$=Window::JKEY;}           
    | T_KKEY             {$$=Window::KKEY;}           
    | T_LKEY             {$$=Window::LKEY;}           
    | T_WKEY             {$$=Window::WKEY;}           
    | T_ZKEY             {$$=Window::ZKEY;}           
    | T_F1               {$$=Window::F1;}         


//---------------------------------------------------------------------
statement_or_block_of_statements:
    statement_block
    | statement


//---------------------------------------------------------------------
statement_block:
    T_LBRACE statement_list T_RBRACE{$$=$2;}
    | T_LBRACE T_RBRACE{$$=new NullStatement;}



//---------------------------------------------------------------------
statement_list:
    statement_list statement
    {
        $1->append_statement($2); 
        $$=$1;
    }
    |statement
    {
            $$=$1;
    }


//---------------------------------------------------------------------
statement:
    if_statement              {$$=$1;}    
    | for_statement           {$$=$1;}   
    | assign_statement T_SEMIC{$$=$1;}
    | print_statement T_SEMIC {$$=$1;} 
    | exit_statement T_SEMIC  {$$=$1;} 
    | repeat_until  T_SEMIC   {$$=$1;}


//---------------------------------------------------------------------
if_statement:
    T_IF T_LPAREN expression T_RPAREN statement_or_block_of_statements %prec IF_NO_ELSE
    {
        if($3->type()==GPL::INT)
        {
            $$=new If($3,$5,new NullStatement);
        }
        else
        {
            Error::error(Error::INVALID_TYPE_FOR_IF_STMT_EXPRESSION);
        }
    }
    | T_IF T_LPAREN expression T_RPAREN statement_or_block_of_statements T_ELSE statement_or_block_of_statements
    {
        if($3->type() == GPL::INT)
            {
                $$ = new If($3, $5, $7);
            }
            else
            {
                Error::error(Error::INVALID_TYPE_FOR_IF_STMT_EXPRESSION);
            }
    }
//---------------------------------------------------------------------
//Repeat until statement
//---------------------------------------------------------------------
repeat_until:
    T_REPEAT statement_or_block_of_statements T_UNTIL T_LPAREN expression T_RPAREN
    {
        if($5->type()==GPL::INT)
        {
            $$=new Repeat($5,$2);
        }
        else
        {
            Error::error(Error::INVALID_TYPE_REPEAT_UNTIL_FOR_STMT_EXPRESSION);
        }
    }
//---------------------------------------------------------------------
for_statement:
    T_FOR T_LPAREN assign_statement_or_empty T_SEMIC expression T_SEMIC assign_statement_or_empty T_RPAREN statement_or_block_of_statements
    {
        if($5->type()==GPL::INT)
        {
            if((!$3)&&(!$7))
            {
                $$=new For(new NullStatement, $5, new NullStatement, $9);
            }
            else if(!$3)
            {
                $$=new For(new NullStatement, $5,$7,$9);
            }
            else if(!$7)
            {
                $$=new For($3,$5,new NullStatement, $9);
            }
            else
            {
                $$=new For($3,$5,$7,$9);
            }
        }
        else
        {
            Error::error(Error::INVALID_TYPE_FOR_FOR_STMT_EXPRESSION);
        }
    }

//---------------------------------------------------------------------
print_statement:
    T_PRINT T_LPAREN expression T_RPAREN
    {
        if($3->type() != INT && $3->type() != DOUBLE && $3->type() != STRING)
        {
            Error::error(Error::INVALID_TYPE_FOR_PRINT_STMT_EXPRESSION);
        }
        $$=new Print($1, $3);
    }


//---------------------------------------------------------------------
exit_statement:
    T_EXIT T_LPAREN expression T_RPAREN
    {
        if($3->type()!=GPL::INT)
        {
            Error::error(Error::EXIT_STATUS_MUST_BE_AN_INTEGER, GPL::to_string($3->type()));
        }
        $$=new Exit($1,$3);
    }

//---------------------------------------------------------------------
assign_statement_or_empty:
    assign_statement
    | %empty
    {
        $$=nullptr;
    }


//---------------------------------------------------------------------
assign_statement:
    variable T_ASSIGN expression
    {
        if(!($1->type() & (GPL::INT| GPL::DOUBLE | GPL::STRING)))
        {
            Error::error(Error::INVALID_LHS_OF_ASSIGNMENT, $1->get_name(), GPL::to_string($1->type()));
            break;
        }
        if($1->type()==GPL::INT)
        {
            if(!(($1->type()==GPL::INT) && ($3->type()==GPL::INT)))
            {
                Error::error(Error::ASSIGNMENT_TYPE_ERROR, GPL::to_string($1->type()), GPL::to_string($3->type()));
                break;
            }
        }
        else if($1->type()==GPL::DOUBLE)
        {
            if(!(($1->type()==GPL::DOUBLE) && ($3->type()&(GPL::DOUBLE|GPL::INT))))
            {
                Error::error(Error::ASSIGNMENT_TYPE_ERROR, GPL::to_string($1->type()), GPL::to_string($3->type()));
                break;
            }
        }
        else if($1->type()==GPL::STRING)
        {
            if(!(($1->type()==GPL::STRING) && ($3->type()&(GPL::DOUBLE|GPL::INT|GPL::STRING))))
            {
                Error::error(Error::ASSIGNMENT_TYPE_ERROR, GPL::to_string($1->type()), GPL::to_string($3->type()));
                break;
            }
        }
        $$=new Assign($1,$3);
    }
    | variable T_PLUS_ASSIGN expression 
    {
        if(!($1->type() & (GPL::INT| GPL::DOUBLE | GPL::STRING)))
        {
            Error::error(Error::INVALID_LHS_OF_PLUS_ASSIGNMENT, $1->get_name(), GPL::to_string($1->type()));
            break;
        }
        if($1->type()==GPL::INT)
        {
            if(!(($1->type()==GPL::INT) && ($3->type()==GPL::INT)))
            {
                Error::error(Error::PLUS_ASSIGNMENT_TYPE_ERROR, GPL::to_string($1->type()), GPL::to_string($3->type()));
                break;
            }
        }
        else if($1->type()==GPL::DOUBLE)
        {
            if(!(($1->type()==GPL::DOUBLE) && ($3->type()&(GPL::DOUBLE|GPL::INT))))
            {
                Error::error(Error::PLUS_ASSIGNMENT_TYPE_ERROR, GPL::to_string($1->type()), GPL::to_string($3->type()));
                break;
            }
        }
        else if($1->type()==GPL::STRING)
        {
            if(!(($1->type()==GPL::STRING) && ($3->type()&(GPL::DOUBLE|GPL::INT|GPL::STRING))))
            {
                Error::error(Error::PLUS_ASSIGNMENT_TYPE_ERROR, GPL::to_string($1->type()), GPL::to_string($3->type()));               break;
            }
        }
        $$ = new Assign($1, new Plus($1, $3));
    }
    | variable T_MINUS_ASSIGN expression
    {
        if(!($1->type() & (GPL::INT| GPL::DOUBLE)))
        {
            Error::error(Error::INVALID_LHS_OF_MINUS_ASSIGNMENT, $1->get_name(), GPL::to_string($1->type()));
            break;
        }
        if($1->type()==GPL::INT)
        {
            if(!(($1->type()==GPL::INT) && ($3->type()==GPL::INT)))
            {
                Error::error(Error::MINUS_ASSIGNMENT_TYPE_ERROR, GPL::to_string($1->type()), GPL::to_string($3->type()));
                break;
            }
        }
        else if($1->type()==GPL::DOUBLE)
        {
            if(!(($1->type()==GPL::DOUBLE) && ($3->type()&(GPL::DOUBLE|GPL::INT))))
            {
                Error::error(Error::MINUS_ASSIGNMENT_TYPE_ERROR, GPL::to_string($1->type()), GPL::to_string($3->type()));
                break;
            }
        }
        else if($1->type()==GPL::STRING)
        {
            if(!(($1->type()==GPL::STRING) && ($3->type()&(GPL::DOUBLE|GPL::INT|GPL::STRING))))
            {
                Error::error(Error::MINUS_ASSIGNMENT_TYPE_ERROR, GPL::to_string($1->type()), GPL::to_string($3->type()));
                break;
            }
        }
        $$ = new Assign($1, new Minus($1, $3));
    }
    | variable T_PLUS_PLUS
    {
        if(!($1->type()==GPL::INT))
        {
            Error::error(Error::INVALID_LHS_OF_PLUS_PLUS, $1->get_name(), GPL::to_string($1->type()));
            break;
        }
        $$ = new Assign($1, new Plus($1, new Integer_constant(1)));
    }
    | variable T_MINUS_MINUS
    {
        if(!($1->type()==GPL::INT))
        {
            Error::error(Error::INVALID_LHS_OF_MINUS_MINUS, $1->get_name(), GPL::to_string($1->type()));
            break;
        }
        $$ = new Assign($1, new Minus($1, new Integer_constant(1)));
    }


//---------------------------------------------------------------------
variable:
    T_ID {
        Scope_manager& sm=Scope_manager::instance();
        if(sm.lookup(*$1)==nullptr)
        {
            Error::error(Error::UNDECLARED_VARIABLE, *$1);
            $$=new Variable("");
            delete $1;
            break;
        }
        if(sm.lookup(*$1)->isArray()){
            Error::error(Error::VARIABLE_IS_AN_ARRAY, *$1);
            $$=new Variable("");
            delete $1;
            break;
        }
        $$=new Variable(*$1);
        delete $1;
    }
    | T_ID T_LBRACKET expression T_RBRACKET {
        Scope_manager& sm=Scope_manager::instance();
        if(sm.lookup(*$1)==nullptr)
        {
            Error::error(Error::UNDECLARED_VARIABLE, *$1+"[]");
            $$=new Variable("");
            delete $1;
            delete $3;
            break;
        }
        if(!sm.lookup(*$1)->isArray())
        {
            Error::error(Error::VARIABLE_NOT_AN_ARRAY, *$1);
            $$=new Variable("");
            delete $1;
            delete $3;
            break;
        }
        if($3->type()!=GPL::INT)
        {
            Error::error(Error::ARRAY_INDEX_MUST_BE_AN_INTEGER,*$1,GPL::to_string($3->type()));
            $$ = new Variable("");
            delete $1;
            delete $3;
            break;
        }
        $$ = new Variable(*$1, $3);
        delete $1;
        //delete $3;
    }
        | T_ID T_PERIOD T_ID {
            Scope_manager& sm=Scope_manager::instance();
            shared_ptr<Symbol> shared_sym = sm.lookup(*$1);
            if(shared_sym!=nullptr)
            {
                if(shared_sym->isArray())
                {
                    Error::error(Error::VARIABLE_IS_AN_ARRAY, *$1);
                    $$=new Variable("");
                    break;
                }
                try{
                    std::shared_ptr<const Constant>(shared_sym->as_constant(*$3));
                }catch(GPL::Type actual_type)
                {
                    Error::error(Error::LHS_OF_PERIOD_MUST_BE_OBJECT, *$1);
                    $$=new Variable("");
                    break;
                }
                catch(const out_of_range& ex)
                {
                    Error::error(Error::UNDECLARED_MEMBER, *$1, *$3);
                    $$=new Variable("");
                    break;
                }
            }
            else
            {
                Error::error(Error::UNDECLARED_VARIABLE, *$1);
                $$=new Variable("");
                break;
            }
            $$=new Member_variable(*$1, *$3);
            delete $1;
            delete $3;
        }
    | T_ID T_LBRACKET expression T_RBRACKET T_PERIOD T_ID {
        Scope_manager& sm=Scope_manager::instance();
        shared_ptr<Symbol> shared_sym = sm.lookup(*$1);
        if($3->type()==GPL::INT)
        {
            if(sm.defined_in_current_scope(*$1))
            {
                if(!shared_sym->isArray())
                {
                    Error::error(Error::VARIABLE_NOT_AN_ARRAY, *$1);
                    $$=new Variable("");
                    break;
                }
                try
                {
                    std::shared_ptr<const Constant>(shared_sym->as_constant(0, *$6));
                }
                catch(const out_of_range& ex)
                {
                    Error::error(Error::UNDECLARED_MEMBER, *$1, *$6);
                    $$=new Variable("");
                    break;
                }
                catch(GPL::Type actual_type)
                {
                    Error::error(Error::LHS_OF_PERIOD_MUST_BE_OBJECT, *$1);
                    $$=new Variable("");
                    break;
                }
            }
            else
            {
                std::string idarr= *$1 + "[]";
                Error::error(Error::UNDECLARED_VARIABLE, idarr);
                $$ = new Variable("");
                break;
            }
        }
        else
        {
            Error::error(Error::ARRAY_INDEX_MUST_BE_AN_INTEGER, *$1, GPL::to_string($3->type()));
            $$ = new Variable("");
            break;
        }
        $$=new Member_variable(*$1, *$6, $3);
        delete $1;
        delete $6;
    }


//---------------------------------------------------------------------

expression:
    primary_expression {$$=$1;}
    | expression T_OR expression             {$$=Bin_op_check<Or, OR>($1, $3, GPL::INT|GPL::DOUBLE);}
    | expression T_AND expression            {$$=Bin_op_check<And, AND>($1, $3, GPL::INT|GPL::DOUBLE);}
    | expression T_LESS_EQUAL expression     {$$=Bin_op_check<Less_equal, LESS_EQUAL>($1, $3, INT|DOUBLE|STRING);}
    | expression T_GREATER_EQUAL  expression {$$=Bin_op_check<Greater_equal, GREATER_EQUAL>($1, $3, INT|DOUBLE|STRING);}
    | expression T_LESS expression           {$$=Bin_op_check<Less_than, LESS_THAN>($1, $3, INT|DOUBLE|STRING);}
    | expression T_GREATER  expression       {$$=Bin_op_check<Greater_than, GREATER_THAN>($1, $3, INT|DOUBLE|STRING);}
    | expression T_EQUAL expression          {$$=Bin_op_check<Equal, EQUAL>($1, $3, INT|DOUBLE|STRING);}
    | expression T_NOT_EQUAL expression      {$$=Bin_op_check<Not_equal, NOT_EQUAL>($1, $3, INT|DOUBLE|STRING);}
    | expression T_PLUS expression           {$$=Bin_op_check<Plus, PLUS>($1, $3, INT|DOUBLE|STRING);}
    | expression T_MINUS expression          {$$=Bin_op_check<Minus, MINUS>($1, $3, GPL::INT|GPL::DOUBLE);}
    | expression T_MULTIPLY expression       {$$=Bin_op_check<Multiply, MULTIPLY>($1, $3, GPL::INT|GPL::DOUBLE);}
    | expression T_NEAR expression           {$$=nullptr; /*CHANGE*/}
    | expression T_TOUCHES expression        {$$=nullptr; /*CHANGE*/}
    | expression T_DIVIDE expression         {$$=Bin_op_check<Divide, DIVIDE>($1, $3, GPL::INT|GPL::DOUBLE);}
    | expression T_MOD expression            {$$=Bin_op_check<Mod, MOD>($1, $3, GPL::INT);}
    | T_MINUS  expression %prec UNARY_OPS    {$$=Un_op_check<Tminus, UNARY_MINUS>($2, GPL::INT|GPL::DOUBLE);}
    | T_NOT  expression                      {$$=Un_op_check<Tnot, NOT>($2, GPL::INT|GPL::DOUBLE);}
    | T_SIN T_LPAREN expression T_RPAREN     {$$=Un_op_check<Tsin, SIN>($3, GPL::INT|GPL::DOUBLE);}
    | T_COS T_LPAREN expression T_RPAREN     {$$=Un_op_check<Tcos, COS>($3, GPL::INT|GPL::DOUBLE);}
    | T_TAN T_LPAREN expression T_RPAREN     {$$=Un_op_check<Ttan, TAN>($3, GPL::INT|GPL::DOUBLE);}
    | T_ASIN T_LPAREN expression T_RPAREN    {$$=Un_op_check<Tasin, ASIN>($3, GPL::INT|GPL::DOUBLE);}
    | T_ACOS T_LPAREN expression T_RPAREN    {$$=Un_op_check<Tacos, ACOS>($3, GPL::INT|GPL::DOUBLE);}
    | T_ATAN T_LPAREN expression T_RPAREN    {$$=Un_op_check<Tatan, ATAN>($3, GPL::INT|GPL::DOUBLE);}
    | T_SQRT T_LPAREN expression T_RPAREN    {$$=Un_op_check<Tsqrt, SQRT>($3, GPL::INT|GPL::DOUBLE);}
    | T_ABS T_LPAREN expression T_RPAREN     {$$=Un_op_check<Tabs, ABS>($3, GPL::INT|GPL::DOUBLE);}
    | T_FLOOR T_LPAREN expression T_RPAREN   {$$=Un_op_check<Tfloor, FLOOR>($3, GPL::INT|GPL::DOUBLE);}
    | T_RANDOM T_LPAREN expression T_RPAREN  {$$=Un_op_check<Trandom, RANDOM>($3, GPL::INT|GPL::DOUBLE);}


//---------------------------------------------------------------------
primary_expression:
    T_LPAREN  expression T_RPAREN {$$= $2;}
    | variable{$$=$1;}
    | T_INT_CONSTANT   {$$ = new Integer_constant($1);}
    | T_TRUE{$$=new const Integer_constant(1);}
    | T_FALSE{$$=new const Integer_constant(0);}
    | T_DOUBLE_CONSTANT{$$=new Double_constant($1);}
    | T_STRING_CONSTANT{$$= new String_constant(*$1); delete $1;}


%%
